## Memory

### Vendor
1. Corsair Component (海盗船，美国内存制造商)
2. Kingston Technology (金士顿，美国内存制造商)
3. Crucial(英睿达，大规模内存和SSD固态硬盘制造厂家)(镁光旗下公司)
4. G.SKILL (芝奇，台湾内存模块专业制造商)
5. Micron Technology(镁光科技，主要业务为生产多种形式的半导体器件)
6. Asus(华硕，跨国硬件及电子组件公司，总部位于台湾)
7. Toshiba Corporation(东芝，日本八大旗舰电机制造商之一)

**以上memory-maker的排名来源于国外排名网站 www.Ranker.com**

### Type
+ RAM（Random Access Memory 随机存储器）

既可以从中读取数据，也可以写入数据。当机器电源关闭时，存于其中的数据就会丢失。（NVRAM不会丢失）

一般计算机中的内存都是RAM。

+ ROM（Read Only Memory 只读存储器）

在制造ROM的时候，信息（数据或程序）就被存入并永久保存。这些信息只能读出，一般不能写入，即使机器停电，这些数据也不会丢失。

ROM一般用于存放计算机的基本程序和数据，如BIOS ROM。

+ FLASH （闪存）

它结合了ROM和RAM的长处，不仅具备电子可擦出可编程（EEPROM）的性能，还不会断电丢失数据同时可以快速读取数据 

一般U盘和MP3中使用闪存

#### RAM的分类

+ DRAM（动态随机访问存储器）

DRAM相比于SRAM来说速度较慢，保留数据的时间很短，计算机大部分内存是DRAM。

DRAM又分为很多种，主要有FPRAM/FastPage、EDORAM、SDRAM、DDR SDRAM（synchronous DRAM）、RDRAM、SGRAM以及WRAM等。

我们一般所用的DRAM是DDR SDRAM（Double Data Rate SDRAM，双倍速率同步动态随机存储器），现在基本使用的是DDR3（第三代DDR），DDR已经发展到DDR4。

+ SRAM（静态随机访问存储器）

SRAM速度非常快，是目前读写最快的存储设备了，但是它也非常昂贵，所以只在要求很苛刻的地方使用，譬如CPU的一级缓冲，二级缓 冲。

+ NVRAM  (非易失性随机访问存储器 Non-Volatile Random Access Memory)

顾名思义，断电之后，所存储的数据不丢失的随机访问存储器

### Key Indicator

+ 内存容量 

内存的容量单位与硬盘、软盘等相同，以字节为最小单位

+ 数据带宽

数据带宽是指内存一次输出/输入的数据量，是衡量内存性能的重要指标。带宽=总线宽度×总线频率×传输倍率（一个时钟周期内交换的数据包个数）
比如DDR的double代表一个时钟周期能传输两次数据。

+ 内存主频

内存主频和CPU主频一样，习惯上被用来表示内存的速度，它代表着该内存所能达到的最高工作频率。内存主频是以MHz（兆赫）为单位来计量的。主频与时钟周期长是相对的概念，两者乘积不变。

+ 存取时间 

存取时间代表了读取数据所延迟的时间。以前人们有个误区，认为它和系统时钟频率有着某种联系，其实二者在本质上是有着显著的区别的，可以说完全是两回事。存取时间和时钟周期一样，越小则越优。

+ CAS延迟时间

简称cl，纵向地址脉冲的反应时间，简单的说，就是内存接到CPU的指令后的反应速度。一般的参数值是2和3两种。数字越小，代表反应所需的时间越短。

值得一提的是，内存带宽计算公式中没有CAS延迟时间，也就是说，计算机中内存的传输速率，在带宽不够的情况下，可以通过减少CAS延迟时间来提升数据传输速率。

### Technology
+ 奇偶校验

奇/偶校验（Parity）是数据传送时采用的一种校正数据错误的一种方式，分为奇校验和偶校验两种。

如果是采用奇校验，在传送每一个字节的时候另外附加一位作为校验位，当实际数据中“1”的个数为偶数的时候，这个校验位就是“1”，否则这个校验位就是“0”，这样就可以保证传送数据满足奇校验的要求。在接收方收到数据时，将按照奇校验的要求检测数据中“1”的个数，如果是奇数，表示传送正确，否则表示传送错误。

同理偶校验的过程和奇校验的过程一样，只是检测数据中“1”的个数为偶数。

**优点：比较简单，它是使用一位数据能够达到的最好的校验码，仅仅需要一些异或门就能够生成。**

**缺点：1.没有办法确定哪一位出错，所以它不能进行错误校正。发生错误时必须扔掉全部的数据，然后从头开始传输数据。**

**2.随着数据位的增加，用来检验的数据位也成倍增加**

+ 错误纠正内存（ECC memory）

ECC与奇偶校验不同的是，如果数据位是8位，则需要增加5位来进行ECC错误检查和纠正。数据位每增加一倍，ECC只增加一位检验位。也就是说当数据位为16位时ECC位为6位，32位时ECC位为7位，数据位为64位时ECC位为8位，依此类推。在内存中ECC能够容许错误，并可以将错误自动更正，使系统得以正常的操作，不致因错误而中断。

**ECC内存现在已经广泛应用在服务器内存中，由于它强大的纠错能力，能够保障服务器的稳定性（宇宙射线都不怕）**

+ REG Memory

在有些服务器的内存中，存在一些寄存器用来做索引或者缓存，大大提高内存读取速度。

+ 内存镜像（Memory Mirroring）

工作原理与硬盘的热备份类似，内存镜像是将内存数据做两个拷贝，分别放在主内存和镜像内存中。
 
### 拓展：DSM（Distributed Shared Memory 分布式内存）


实现分布式内存（DSM）的方法主要有三种

+ 用硬件实现。实际上是传统的高速缓存(cache)技术在可扩展体系结构中的延伸。

+ 操作系统和程序库的实现方法，通过虚拟内存管理机制实现共享和一致性。

+ 编译实现，自动将共享访问转变为同步和一致性原语。

这两天读了一篇论文[Memory coherence in shared virtual memory systems](https://dl.acm.org/citation.cfm?id=10610)，介绍了DSM的一种抽象模型。

首先在DSM访问单元的粒度上有一个tradeoff，访问单元太大，内存访问冲突的几率会增大，访问单元太小，overhead相对较大会产生效率上的问题，最终选取了pagesize作为访问粒度。

之后在同步的问题上又进行了一个选择，及一个页被write修改之后，应该采取invalidate其他cpu上备份，还是writeback这些备份。这个问题感觉有点类似于观察者模式中的推模型和拉模型。最终实验的结果是invalidate的方法性能最好。

关于内存访问读取的同步算法，论文中一步一步做了优化，在算法上有以下分类：

+ 按内存页的所有权分为静态分配页与动态分配页，及页的所有权会不会发生变化

+ 在动态分配算法中，又按照manager形式分为中央内存管理与分布式内存管理

+ 在分布式内存管理中又分为固定与动态

由于在静态分配页的方式中，每次读取非自己所有的页都要出发fault，使得性能急剧下降，所以率先舍弃。

在动态分配页中，我们势必要为每个页维护两个信息，所有者cpu与copy_set（包含这个页的一份拷贝的所有cpu）

在中央manager进行唯一调度转发的算法中，我们进行了良好的同步，但是问题出现了，由于每次fault都要去给central manager发消息，其实这就导致了对central manager要求非常高，把太多的责任分配给了manager，第一是容易形成性能瓶颈，第二我认为manager如果挂掉会使得整个系统无法运行，容错也很差。

之后论文进行了一个tradeoff，将copy_set的信息维护在这个页的所有者处，这样每个cpu的每个页都要增加copy_set字段，而且只有cpu拥有一个页的时候copy_set才有效，这造成了大量的内存浪费，但是这大大减轻了central manager的压力，使得性能得到了提高，这是用存储空间来换性能。

为了进一步减少manager的压力，论文干脆直接采用了分布式的manager，让每个cpu都成为一个manager，共同分担维护内存页信息的责任。

在如何分配管理责任上，又出现了动态与静态的方式，静态的方式用一个函数来唯一确定哪个页归谁管理，而动态的方式使得每个manager管理的页动态变化，相比于静态分配管理权来讲，对于每一种内存读取情况，性能的变化幅度相对与静态要更小，这增加了DSM的稳定性，所以我们最终采取了动态分配管理权限的方式。

之后的论文又在一些细节上做了一些优化，在此不再赘述。

从整个优化过程来看，它主要采取三种优化思路

+ **将message passing进行平均分配，让每个cpu都充当manager的角色，最大化利用cpu资源，减少在某一节点上出现性能瓶颈的可能。**

+ **用空间换时间，增加copy_set信息的备份，用增加备份的方式减少互相之间的沟通请求**

+ **动态的调整管理页集合，这样使得整个系统面对不同的情况均能表现出接近的性能，使得系统不会因为内存读取情况的不同而在performance上出现过大差异。使得系统更加稳定。**